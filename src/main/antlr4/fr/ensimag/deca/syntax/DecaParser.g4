parser grammar DecaParser;

options {
	// Default language but name it anyway
	language = Java;

	// Use a superclass to implement all helper methods, instance variables and overrides of ANTLR
	// default methods, such as error handling.
	superClass = AbstractDecaParser;

	// Use the vocabulary generated by the accompanying lexer. Maven knows how to work out the
	// relationship between the lexer and parser and will build the lexer before the parser. It will
	// also rebuild the parser if the lexer changes.
	tokenVocab = DecaLexer;
}

// which packages should be imported?
@header {
    import fr.ensimag.deca.tree.*;
    import fr.ensimag.deca.tools.*;
    import fr.ensimag.deca.context.*;
    import fr.ensimag.deca.tools.SymbolTable.Symbol;
    import fr.ensimag.deca.DecacCompiler;
    import java.io.PrintStream;
    import java.util.*;
    import java.lang.*;
}

@members {
    @Override
    protected AbstractProgram parseProgram() {
        return prog().tree;
    }

    boolean tab() {
        return super.getDecacCompiler().getCompilerOptions().enableTabs();
    }
}

prog
	returns[AbstractProgram tree]:
	list_classes main EOF {
            assert($list_classes.tree != null);
            assert($main.tree != null);
            $tree = new Program($list_classes.tree, $main.tree);
            setLocation($tree, $list_classes.start);
        };

main
	returns[AbstractMain tree]:
	/* epsilon */ {
            $tree = new EmptyMain();
        }
	| block {
            assert($block.decls != null);
            assert($block.insts != null);
            $tree = new Main($block.decls, $block.insts);
            setLocation($tree, $block.start);
        };

block
	returns[ListDeclVar decls, ListInst insts]:
	OBRACE list_decl list_inst CBRACE {
            assert($list_decl.tree != null);
            assert($list_inst.tree != null);
            $decls = $list_decl.tree;
            $insts = $list_inst.tree;
        };

list_decl
	returns[ListDeclVar tree]
	@init {
            $tree = new ListDeclVar();
        }: decl_var_set[$tree]*;

decl_var_set[ListDeclVar l]:
	type list_decl_var[$l,$type.tree] SEMI;

list_decl_var[ListDeclVar l, AbstractIdentifier t]:
	dv1 = decl_var[$t] {
        $l.add($dv1.tree);
        } (
		COMMA dv2 = decl_var[$t] {
        $l.add($dv2.tree);
        }
	)*;

decl_var[AbstractIdentifier t]
	returns[AbstractDeclVar tree]
	@init {
                $t.setDefinition(super.getDecacCompiler().environmentType.defOfType(t.getName()));
                AbstractInitialization in;
        }:
	    i = ident {
                in = new NoInitialization();
                setLocation(in, $i.start);
        } (
		EQUALS e = expr {
                in = new Initialization($e.tree);
                setLocation(in, $e.start);
        })? {
                $tree = new DeclVar($t, $i.tree, in);
                setLocation($tree, $i.start);
    };

list_inst
	returns[ListInst tree]
	@init {
    $tree = new ListInst();
}: (
		inst {
            AbstractInst newNode = $inst.tree; 
            setLocation(newNode, $inst.start);
            $tree.add($inst.tree);
        }
	)*;

inst
	returns[AbstractInst tree]:
	e1 = expr SEMI {
            assert($e1.tree != null);
            $tree = $e1.tree;
        }
	| SEMI {
        $tree = new NoOperation();
        }
	| PRINT OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Print(false, $list_expr.tree);
            setLocation($tree, $list_expr.start);
        }
	| PRINTLN OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Println(false, $list_expr.tree);
            setLocation($tree, $list_expr.start);
        }
	| PRINTX OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Print(true, $list_expr.tree);
            setLocation($tree, $list_expr.start);
        }
	| PRINTLNX OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Println(true, $list_expr.tree);
            setLocation($tree, $list_expr.start);
        }
	| if_then_else {
            assert($if_then_else.tree != null);
            $tree = $if_then_else.tree;
            setLocation($tree, $if_then_else.start);
        }
	| WHILE OPARENT condition = expr CPARENT OBRACE body = list_inst CBRACE {
            assert($condition.tree != null);
            assert($body.tree != null);
            $tree = new While($expr.tree, $list_inst.tree);
            setLocation($tree, $list_inst.start);
        }
	| RETURN expr SEMI {
            assert($expr.tree != null);
            $tree = new Return($expr.tree);
            setLocation($tree, $expr.start);
        };

if_then_else
	returns[IfThenElse tree]
	@init {
        IfThenElse currentIfElse;

        IfThenElse lastIfElse;
    }:
	if1 = IF OPARENT condition = expr CPARENT OBRACE li_if = list_inst CBRACE {
        assert($expr.tree != null);
        assert($list_inst.tree != null);

        $tree = new IfThenElse($condition.tree, $li_if.tree, new ListInst());
        currentIfElse = $tree;
        lastIfElse = currentIfElse;

        setLocation($tree, $li_if.start);
    } (
		ELSE elsif = IF OPARENT elsif_cond = expr CPARENT OBRACE elsif_li = list_inst CBRACE {
        assert($elsif_cond.tree != null);
        assert($elsif_li.tree != null);

        IfThenElse otherIfElse = new IfThenElse($elsif_cond.tree, $elsif_li.tree, new ListInst());
        setLocation(otherIfElse, $elsif_li.start);

        ListInst elseBranch = new ListInst();
        elseBranch.add(otherIfElse);
        lastIfElse.setElseBranch(elseBranch);

        lastIfElse = otherIfElse;
    }
	)* (
		ELSE OBRACE li_else = list_inst CBRACE {
        assert($li_else.tree != null);
        lastIfElse.setElseBranch($li_else.tree);
    }
	)?;

list_expr
	returns[ListExpr tree]
	@init {
        $tree = new ListExpr();
        }: (
		e1 = expr {
        $tree.add($e1.tree);
        } (
			COMMA e2 = expr {
        $tree.add($e2.tree);
        }
		)*
	)?;

expr
	returns[AbstractExpr tree]:
	assign_expr {
            assert($assign_expr.tree != null);
            $tree = $assign_expr.tree;
            setLocation($tree, $assign_expr.start);
        };

assign_expr
	returns[AbstractExpr tree]:
	e = or_expr (
		/* condition: expression e must be a "LVALUE" */ {
            if (! ($e.tree instanceof AbstractLValue)) {
                throw new InvalidLValue(this, $ctx);
            }
            $tree = $e.tree;
            setLocation($tree, $e.start);
        } EQUALS e2 = assign_expr {
            assert($e.tree != null);
            assert($e2.tree != null);
            $tree = new Assign((AbstractLValue) $e.tree, $e2.tree);
            setLocation($tree, $assign_expr.start);
        }
		| /* epsilon */ {
            assert($e.tree != null);
            $tree = $e.tree;
        }
	);

or_expr
	returns[AbstractExpr tree]:
	e = and_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = or_expr OR e2 = and_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Or($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
       };

and_expr
	returns[AbstractExpr tree]:
	e = eq_neq_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = and_expr AND e2 = eq_neq_expr {
            assert($e1.tree != null);                         
            assert($e2.tree != null);
            $tree = new And($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        };

eq_neq_expr
	returns[AbstractExpr tree]:
	e = inequality_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = eq_neq_expr EQEQ e2 = inequality_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Equals($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = eq_neq_expr NEQ e2 = inequality_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new NotEquals($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        };

inequality_expr
	returns[AbstractExpr tree]:
	e = sum_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = inequality_expr LEQ e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new LowerOrEqual($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = inequality_expr GEQ e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new GreaterOrEqual($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = inequality_expr GT e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Greater($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = inequality_expr LT e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Lower($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = inequality_expr INSTANCEOF type {
            assert($e1.tree != null);
            assert($type.tree != null);
            $tree = new InstanceOf($e1.tree, $type.tree);
            setLocation($tree, $e1.start);        
        };

sum_expr
	returns[AbstractExpr tree]:
	e = mult_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = sum_expr PLUS e2 = mult_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Plus($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = sum_expr MINUS e2 = mult_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Minus($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        };

mult_expr
	returns[AbstractExpr tree]:
	e = unary_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = mult_expr TIMES e2 = unary_expr {
            assert($e1.tree != null);                                         
            assert($e2.tree != null);
            $tree = new Multiply($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = mult_expr SLASH e2 = unary_expr {
            assert($e1.tree != null);                                         
            assert($e2.tree != null);
            $tree = new Divide($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        }
	| e1 = mult_expr PERCENT e2 = unary_expr {
            assert($e1.tree != null);                                                                          
            assert($e2.tree != null);
            $tree = new Modulo($e1.tree, $e2.tree);
            setLocation($tree, $e1.start);
        };

unary_expr
	returns[AbstractExpr tree]:
	op = MINUS e = unary_expr {
            assert($e.tree != null);
            $tree = new UnaryMinus($e.tree);
            setLocation($tree, $e.start);
        }
	| op = EXCLAM e = unary_expr {
            assert($e.tree != null);
            $tree = new Not($e.tree);
            setLocation($tree, $e.start);
        }
	| select_expr {
            assert($select_expr.tree != null);
            $tree = $select_expr.tree;
            setLocation($tree, $select_expr.start);
        };

select_expr
	returns[AbstractExpr tree]:
	e = primary_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            setLocation($tree, $e.start);
        }
	| e1 = select_expr DOT i = ident {
            assert($e1.tree != null);
            assert($i.tree != null);
        } (
		o = OPARENT args = list_expr CPARENT {
            // we matched "e1.i(args)"
            assert($args.tree != null);
            $tree = new MethodCall($e1.tree, $i.tree, $args.tree);
            setLocation($tree, $args.start);
        }
		| /* epsilon */ {
            $tree = new Selection($e1.tree, $i.tree);
            setLocation($tree, $e1.start);
        }
	);

primary_expr
	returns[AbstractExpr tree]
    @init {
        ListExpr newListChildren = new ListExpr();
        ArrayExpr newArray = new ArrayExpr(newListChildren);
        ListExpr indices = new ListExpr();
    }:
	ident {
            assert($ident.tree != null);
            $tree = $ident.tree;
        }
        | {tab()}? OBRACE list_expr CBRACE {
            assert($list_expr.tree != null);
            $tree = new ArrayExpr($list_expr.tree);
            setLocation($tree, $list_expr.start);
        }
        | {tab()}? ident (OBRACKET e = expr CBRACKET {
                indices.getModifiableList().add($e.tree);
        })+ {
                assert($ident.tree != null);
                $tree = new ArraySelector($ident.tree, indices);
                setLocation($tree, $ident.start);
        }
	| m = ident OPARENT args = list_expr CPARENT {
            assert($args.tree != null);
            assert($m.tree != null);
            This thisExpr = new This(true);
            setLocation(thisExpr, $m.start);
            $tree = new MethodCall(thisExpr, $m.tree, $args.tree);
            setLocation($tree, $args.start);
        }
	| OPARENT e = expr CPARENT {
            assert($expr.tree != null);
            $tree = $e.tree;
        }
	| rI = READINT OPARENT CPARENT {
            $tree = new ReadInt();
        } 
	| rF = READFLOAT OPARENT CPARENT {
            $tree = new ReadFloat();
        }
	| NEW ident OPARENT CPARENT {
            assert($ident.tree != null);
            $tree = new New($ident.tree);
            setLocation($tree, $ident.start);
        }
	| cast = OPARENT type CPARENT OPARENT expr CPARENT {
            assert($type.tree != null);
            assert($expr.tree != null);
            $tree = new Cast($type.tree, $expr.tree);
            setLocation($tree, $type.start);
        }
	| literal {
            if ($literal.tree == null) {
                LocationException errorMsg = new LocationException("NUMBER_OVERSIZED_EXCEPTION: The integer or float you have entered could not be parsed (probably because it's too large or too small)", tokenLocation($literal.start));
                System.err.println(errorMsg.getMessageWithLocation());
                System.exit(1);
            }
            $tree = $literal.tree;

        };

type
	returns[AbstractIdentifier tree]
    @init {
        ArrayList<AbstractExpr> listType = new ArrayList<AbstractExpr>();
        DecacCompiler compiler = super.getDecacCompiler();
    }:
	ident (/* epsilon */ {
            assert($ident.tree != null);
            $tree = $ident.tree;
        } | {tab()}? ((OBRACKET e = expr CBRACKET {
                listType.add($e.tree);
        })+ | {tab()}? (OBRACKET CBRACKET {
                listType.add(new EmptyExpr());
        })+)) {
            $tree = $ident.tree;
            if (!listType.isEmpty()) {
                String name = $ident.text;
                int size = listType.size();
                for (int i = size - 1; i >= 0; i --) {
                    name = name + "[]";
                    $tree = new ArrayIdentifier(compiler.symbolTable.create(name), listType.get(i), $tree);
                }
            }
            setLocation($tree, $ident.start);
        };

literal
	returns[AbstractExpr tree]
    @init {
        FloatLiteral f = null;
    }:
	INT {
        try {
            $tree = new IntLiteral(Integer.parseInt($INT.text));
        } catch(NumberFormatException e) { 
            $tree = null;
        }
        }
	| fd = FLOAT {
        try {
            f = new FloatLiteral(Float.parseFloat($fd.text));
            $tree = f;
            int isFPresent = $fd.text.charAt($fd.text.length() - 1) == '0' ? 1 : 2;
            if (Float.compare(f.getValue(), 0f) == 0 && ! ($fd.text.charAt($fd.text.length() - isFPresent) == '0') )
                throw new IllegalArgumentException(); //if parseFloat has set the value to 0.0f whereas it was really small but non equal to 0 = underflow

        } catch(IllegalArgumentException e) {
            $tree = null;
        }
        }
	| STRING {
        $tree = new StringLiteral($STRING.text);
        }
	| TRUE {
        $tree = new BooleanLiteral(true);
        }
	| FALSE {
        $tree = new BooleanLiteral(false);
        }
	| THIS {
        $tree = new This(false);
        }
	| NULL {
        $tree = new Null();
        };

ident
	returns[AbstractIdentifier tree]:
	i = IDENT {
        $tree = new Identifier(super.getDecacCompiler().symbolTable.create($i.text));
        setLocation($tree, $i);
        };

/****     Class related rules     ****/
//TODO

list_classes
	returns[ListDeclClass tree]
	@init {
        $tree = new ListDeclClass();
    }:
	(c1 = class_decl {
        setLocation($c1.tree, $c1.start);
        $tree.add($c1.tree);
        } 
	)*;

class_decl 
    returns [AbstractDeclClass tree]:
	CLASS name = ident superclass = class_extension OBRACE class_body CBRACE {
        assert($ident.tree != null);
        $tree = new DeclClass($name.tree, $superclass.tree, $class_body.fields, $class_body.methods);
    };

class_extension
	returns[AbstractIdentifier tree]:
	e=EXTENDS ident {
        assert($ident.tree != null);
        $tree = $ident.tree;
        }
	| /* epsilon */ {
        $tree = new Identifier(super.getDecacCompiler().symbolTable.create("Object"));
        $tree.setLocation(Location.BUILTIN);
        };

class_body
    returns[ListDeclMethod methods, ListDeclField fields]
    @init { 
        $methods = new ListDeclMethod();
        $fields = new ListDeclField();
}: (
		m = decl_method {
            assert($decl_method.tree != null);
            $methods.add($decl_method.tree);
        }
		| decl_field_set[$fields]
	)*;

decl_field_set[ListDeclField l]:
    v = visibility t = type list_decl_field[$l, $t.tree, $v.tree] SEMI;

visibility
    returns [Visibility tree]:
	/* epsilon */ {
        $tree = Visibility.PUBLIC;
        }
	| PROTECTED {
        $tree = Visibility.PROTECTED;
        };

list_decl_field[ListDeclField l, AbstractIdentifier t, Visibility v]: 
    
    dv1 = decl_field[$v, $t] {
        $l.add($dv1.tree);
    } (
        COMMA dv2 = decl_field[$v, $t] {
            $l.add($dv2.tree);
        }
    )*;

decl_field[Visibility v, AbstractIdentifier t]
    returns [AbstractDeclField tree]
    @init {
        AbstractInitialization in;
    }:
	i = ident {
        assert($ident.tree != null);
        in = new NoInitialization();
        setLocation(in, $i.start);
        } (
		EQUALS e = expr {
            assert($e.tree != null);
            in = new Initialization($e.tree);
            setLocation(in, $e.start);
        }
	)? {
        $tree = new DeclField($v, $t, $i.tree, in);
        setLocation($tree, $i.start);
    };

decl_method
    returns [AbstractDeclMethod tree]
	@init {
        AbstractMethodBody methodBody;
}:
	type ident OPARENT params = list_params CPARENT (
		block {
            methodBody = new MethodBody($block.decls, $block.insts);
            setLocation(methodBody, $block.start);
        }
		| ASM OPARENT code = multi_line_string CPARENT SEMI {
            StringLiteral multiString = new StringLiteral($code.text);
            methodBody = new MethodAsmBody(multiString);
            setLocation(methodBody, $code.start);
            multiString.setLocation($code.location);
        }
	) {
        assert($type.tree != null);
        assert($ident.tree != null);
        $tree = new DeclMethod($type.tree, $ident.tree, $list_params.tree, methodBody);
        setLocation($tree, $type.start);
    };

list_params
    returns [ListDeclParam tree]
    @init {
        $tree = new ListDeclParam();
    }: (
		p1 = param {
            $tree.add($p1.tree);
        } (
			COMMA p2 = param {
                $tree.add($p2.tree);
            }
		)*
	)?;

multi_line_string
	returns[String text, Location location]:
	s = STRING {
            $text = $s.text;
            $location = tokenLocation($s);
        }
	| s = MULTI_LINE_STRING {
            $text = $s.text;
            $location = tokenLocation($s);
        };

param
    returns [AbstractDeclParam tree]:
	type ident {
        assert($ident.tree != null);
        $tree = new DeclParam($type.tree, $ident.tree);
        setLocation($tree, $type.start);
        };
